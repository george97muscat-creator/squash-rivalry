<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Alex vs George</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background:#f4f6f8; padding:20px; }
.card { background:white; padding:15px; margin-bottom:15px; border-radius:12px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }
input, textarea { width: 70px; margin:3px; }
textarea { width: 100%; height:50px; }
button { padding:8px 12px; border-radius:8px; border:none; background:black; color:white; margin-top:5px; cursor:pointer; }
button.danger { background:#b00020; }
button.small { padding:4px 8px; border-radius:6px; font-size:12px; margin-left:8px; }
table { width:100%; border-collapse:collapse; }
th,td { padding:6px; text-align:center; border-bottom:1px solid #eee; }
.muted { color:#666; font-size:12px; }
.row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
.grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
.badge { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; margin-left:8px; }
.badge-ok { background:#e9f7ee; color:#0b6b0b; }
.badge-nr { background:#fdecec; color:#b00020; }
#status { margin: 10px 0 15px 0; }
.status-ok { color:#0b6b0b; }
.status-err { color:#b00020; white-space: pre-wrap; }
.smallnote { font-size:12px; color:#666; margin-top:6px; }
hr { border:none; border-top:1px solid #eee; margin:12px 0; }
</style>
</head>
<body>

<h1>üèÜ Alex vs George</h1>
<div id="status" class="muted">Loading‚Ä¶</div>

<div class="card">
  <h2>Leaderboard</h2>
  <div class="smallnote">Ordered by <b>Seasons Won</b>. Other columns are stats from <b>completed</b> matches only.</div>
  <table id="leaderboard"></table>
</div>

<div class="card">
  <h2>Current Season</h2>
  <div id="seasonScore"></div>
  <div class="muted" id="seasonMeta"></div>
</div>

<div class="card">
  <h2>Add Match</h2>
  <div class="smallnote">Enter each game score as <b>Alex ‚Äì George</b>. A match is ‚ÄúCompleted‚Äù only when someone wins <b>3 valid games</b> (to 15, win by 2).</div>
  <div id="inputs"></div>
  <button id="addMatchBtn">Add Match</button>
</div>

<div class="card">
  <h2>Match History</h2>
  <div class="muted">Tip: Deleting a match automatically recalculates season scores and winners.</div>
  <div id="history"></div>
</div>

<div class="card">
  <h2>Charts (percentages)</h2>

  <div class="smallnote"><b>Win % by day of week</b> (completed matches only). Bars are 0‚Äì100%.</div>
  <canvas id="weekdayWinRateChart"></canvas>

  <hr>

  <div class="grid2">
    <div>
      <div class="smallnote"><b>Comeback Match Win %</b>: of a player‚Äôs match wins, what % were wins where they trailed by 1+ games at some point? (completed matches only)</div>
      <canvas id="comebackMatchChart"></canvas>
    </div>
    <div>
      <div class="smallnote"><b>Comeback Season Win %</b>: of seasons won, what % were seasons where they trailed by 1+ matches at some point?</div>
      <canvas id="comebackSeasonChart"></canvas>
    </div>
  </div>
</div>

<script type="module">

const firebaseConfig = {
  apiKey: "AIzaSyDfpeuk-5wI3bAAOh799W20ZjCNKj6G4Nc",
  authDomain: "squash-rivalry.firebaseapp.com",
  projectId: "squash-rivalry",
  storageBucket: "squash-rivalry.firebasestorage.app",
  messagingSenderId: "9288441167",
  appId: "1:9288441167:web:2bf24a4bfdbe7af385b93a"
};

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

let data;

let weekdayWinRateChartInstance = null;
let comebackMatchChartInstance = null;
let comebackSeasonChartInstance = null;

function setStatusOk(msg){
  const el = document.getElementById("status");
  el.className = "muted status-ok";
  el.textContent = msg;
}
function setStatusErr(msg){
  const el = document.getElementById("status");
  el.className = "muted status-err";
  el.textContent = msg;
}

function pad2(n){ return String(n).padStart(2, "0"); }

function getWeekdayShortFromISODate(isoDate){
  if(!isoDate) return "";
  const d = new Date(isoDate + "T00:00:00");
  if(isNaN(d.getTime())) return "";
  return ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][d.getDay()];
}

function formatDateTimeNice(date, time){
  const wd = getWeekdayShortFromISODate(date);
  if(!date && !time) return "N/A";
  if(date && time) return `${wd} ${date} ${time}`;
  if(date) return `${wd} ${date}`;
  return time;
}

function setDateTimeToNow(){
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = pad2(d.getMonth()+1);
  const dd = pad2(d.getDate());
  const hh = pad2(d.getHours());
  const mi = pad2(d.getMinutes());
  const dateEl = document.getElementById("matchDate");
  const timeEl = document.getElementById("matchTime");
  if(dateEl) dateEl.value = `${yyyy}-${mm}-${dd}`;
  if(timeEl) timeEl.value = `${hh}:${mi}`;
}

function resetMatchEntryForm(){
  for(let i=0;i<5;i++){
    const a = document.getElementById("a"+i);
    const b = document.getElementById("b"+i);
    if(a) a.value = "";
    if(b) b.value = "";
  }
  const report = document.getElementById("matchReport");
  if(report) report.value = "";
  setDateTimeToNow();
}

async function loadData(){
  try {
    setStatusOk("Loading‚Ä¶");
    const snap = await getDoc(doc(db,"squash","main"));
    if(snap.exists()){
      data = snap.data();
    } else {
      data = {
        players:["Alex","George"],
        seasons:[{matches:[],wins:[0,0],winner:null}]
      };
      await saveData();
    }
    renderAll();
    setStatusOk("Loaded ‚úì");
  } catch (e){
    console.error(e);
    setStatusErr("Error loading data.\n\n" + (e?.message || e));
  }
}

async function saveData(){
  await setDoc(doc(db,"squash","main"),data);
}

function flattenMatchesInStoredOrder(){
  const all = [];
  data.seasons.forEach(season => {
    (season.matches || []).forEach(match => all.push(match));
  });
  return all;
}

/* ---------- RULE LOGIC ---------- */

/**
 * A valid squash game score must:
 * - have someone reach 15+ AND
 * - be won by at least 2 points
 */
function getValidGameWinner(a, g){
  if(typeof a !== "number" || typeof g !== "number") return null;
  const max = Math.max(a, g);
  const diff = Math.abs(a - g);

  if(max < 15) return null;
  if(diff < 2) return null;

  return (a > g) ? 0 : 1; // 0 = Alex, 1 = George
}

/**
 * From entered game scores, compute:
 * - gameWins: [alexGamesWon, georgeGamesWon]
 * - trailedByOneOrMoreAtAnyPoint for each player (during this match)
 * - completed + winner when someone reaches 3 valid game wins
 */
function computeMatchOutcome(games){
  let gameWins = [0,0];

  // Track whether eventual winner had trailed by 1+ games at any point
  // We'll track for both players so we can compute comeback wins for either.
  let alexTrailed = false;
  let georgeTrailed = false;

  for(const game of games){
    const w = getValidGameWinner(game.a, game.g);
    if(w === null) continue;

    gameWins[w]++;

    // After updating score, check if someone is trailing by 1+
    if(gameWins[0] < gameWins[1]) alexTrailed = true;
    if(gameWins[1] < gameWins[0]) georgeTrailed = true;

    // Stop evaluating once match is decided (first to 3)
    if(gameWins[0] >= 3 || gameWins[1] >= 3) break;
  }

  const completed = (gameWins[0] >= 3 || gameWins[1] >= 3);
  const winner = completed ? (gameWins[0] > gameWins[1] ? 0 : 1) : null;

  // comebackWin indicates: winner was trailing by 1+ games at some point
  let comebackWin = false;
  if(completed && winner === 0) comebackWin = alexTrailed;
  if(completed && winner === 1) comebackWin = georgeTrailed;

  return { completed, winner, gameWins, comebackWin };
}

/* ---------- SEASON REBUILD ---------- */
/**
 * Rebuild seasons from scratch based on match order currently stored.
 * Only COMPLETED matches count toward season wins.
 */
function rebuildSeasonsFromMatches(allMatches){
  const seasons = [];
  let current = { matches: [], wins: [0,0], winner: null };

  for(const match of allMatches){
    current.matches.push(match);

    if(match && match.completed && (match.winner === 0 || match.winner === 1)){
      current.wins[match.winner]++;

      if(current.wins[match.winner] >= 5 && current.winner === null){
        current.winner = match.winner;
        seasons.push(current);
        current = { matches: [], wins: [0,0], winner: null };
      }
    }
  }

  seasons.push(current); // keep open season
  data.seasons = seasons;
}

function getCurrentSeason(){
  return data.seasons[data.seasons.length-1];
}

/* ---------- STATS ---------- */
function calculateStats(){
  let stats=[
    {name:"Alex",seasons:0,matches:0,gamesWon:0,gamesLost:0,pointsDiff:0},
    {name:"George",seasons:0,matches:0,gamesWon:0,gamesLost:0,pointsDiff:0}
  ];

  data.seasons.forEach(s=>{
    if(s.winner!==null) stats[s.winner].seasons++;

    (s.matches || []).forEach(m=>{
      // Only completed matches count in core stats
      if(!m || !m.completed) return;

      if(m.winner === 0 || m.winner === 1) stats[m.winner].matches++;

      // Count only VALID games (so unfinished weird scores don‚Äôt pollute)
      (m.games || []).forEach(g=>{
        const w = getValidGameWinner(g.a, g.g);
        if(w === null) return;

        const a = g.a;
        const b = g.g;

        stats[0].gamesWon += a>b ? 1 : 0;
        stats[1].gamesWon += b>a ? 1 : 0;
        stats[0].gamesLost += a<b ? 1 : 0;
        stats[1].gamesLost += b<a ? 1 : 0;

        stats[0].pointsDiff += a - b;
        stats[1].pointsDiff += b - a;
      });
    });
  });

  return stats.sort((a,b)=>b.seasons-a.seasons);
}

/* ---------- ANALYTICS ---------- */
function computeWeekdayWinRatesPercent(){
  const labels = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];
  const totals = labels.map(() => [0,0]);
  const wins = labels.map(() => [0,0]);

  data.seasons.forEach(season => {
    (season.matches || []).forEach(match => {
      if(!match || !match.completed) return;
      if(match.winner !== 0 && match.winner !== 1) return;
      if(!match.date) return;

      const wd = getWeekdayShortFromISODate(match.date);
      const idx = labels.indexOf(wd);
      if(idx === -1) return;

      totals[idx][0] += 1;
      totals[idx][1] += 1;
      wins[idx][match.winner] += 1;
    });
  });

  const alexPct = labels.map((_, i) => totals[i][0] ? (wins[i][0] / totals[i][0]) * 100 : 0);
  const georgePct = labels.map((_, i) => totals[i][1] ? (wins[i][1] / totals[i][1]) * 100 : 0);

  return { labels, alexPct, georgePct };
}

/**
 * Comeback Match Win %:
 * of a player's match wins, what % were comeback wins (trailed by 1+ games at some point)?
 */
function computeComebackMatchWinPercent(){
  const wins = [0,0];
  const comebackWins = [0,0];

  data.seasons.forEach(season => {
    (season.matches || []).forEach(m => {
      if(!m || !m.completed) return;
      if(m.winner !== 0 && m.winner !== 1) return;

      wins[m.winner]++;

      if(m.comebackWin === true) comebackWins[m.winner]++;
    });
  });

  const pct = [
    wins[0] ? (comebackWins[0] / wins[0]) * 100 : 0,
    wins[1] ? (comebackWins[1] / wins[1]) * 100 : 0
  ];

  return { wins, comebackWins, pct };
}

/**
 * Comeback Season Win %:
 * of seasons won, what % did the eventual winner trail by 1+ matches at some point in that season?
 *
 * We compute this by replaying completed matches in each season and checking if the eventual
 * season winner was ever behind in match-win count.
 */
function computeComebackSeasonWinPercent(){
  let seasonsWon = [0,0];
  let comebackSeasons = [0,0];

  data.seasons.forEach(season => {
    if(season.winner !== 0 && season.winner !== 1) return;

    const w = season.winner;
    seasonsWon[w]++;

    let score = [0,0];
    let winnerTrailed = false;

    (season.matches || []).forEach(m => {
      if(!m || !m.completed) return;
      if(m.winner !== 0 && m.winner !== 1) return;

      score[m.winner]++;

      // winner trails if their score < opponent score
      if(score[w] < score[1-w]) winnerTrailed = true;
    });

    if(winnerTrailed) comebackSeasons[w]++;
  });

  const pct = [
    seasonsWon[0] ? (comebackSeasons[0] / seasonsWon[0]) * 100 : 0,
    seasonsWon[1] ? (comebackSeasons[1] / seasonsWon[1]) * 100 : 0
  ];

  return { seasonsWon, comebackSeasons, pct };
}

/* ---------- RENDER ---------- */
function escapeHtml(str){
  return String(str)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function renderAll(){
  renderLeaderboard();
  renderSeasonScore();
  renderHistory();
  renderCharts();
}

function renderLeaderboard(){
  const stats = calculateStats();
  let html="<tr><th>Player</th><th>Seasons</th><th>Matches</th><th>Games W</th><th>Games L</th><th>Points Diff</th></tr>";
  stats.forEach(p=>{
    html+=`<tr>
      <td>${p.name}</td>
      <td>${p.seasons}</td>
      <td>${p.matches}</td>
      <td>${p.gamesWon}</td>
      <td>${p.gamesLost}</td>
      <td>${p.pointsDiff}</td>
    </tr>`;
  });
  document.getElementById("leaderboard").innerHTML=html;
}

function renderSeasonScore(){
  const s = getCurrentSeason();
  document.getElementById("seasonScore").innerText =
    "Alex " + (s.wins?.[0] ?? 0) + " - " + (s.wins?.[1] ?? 0) + " George";
  document.getElementById("seasonMeta").innerText =
    "Season " + data.seasons.length + " (current)";
}

function renderHistory(){
  let html="";

  data.seasons.forEach((s, si)=>{
    html += `<div style="margin-top:10px;"><b>Season ${si+1}</b></div>`;

    if(!s.matches || s.matches.length === 0){
      html += `<div class="muted">No matches logged yet.</div>`;
      return;
    }

    s.matches.forEach((m, mi)=>{
      const when = formatDateTimeNice(m.date || "", m.time || "");
      const report = m.report || "";
      const gamesStr = (m.games || []).map(g => `${g.a}-${g.g}`).join(", ");

      const badge = m.completed
        ? `<span class="badge badge-ok">Completed</span>`
        : `<span class="badge badge-nr">No Result</span>`;

      const winnerText = (m.completed && (m.winner === 0 || m.winner === 1))
        ? data.players[m.winner]
        : "N/A";

      // show game wins if available
      const gw = m.gameWins || [0,0];

      html += `<div style="margin-top:8px; padding:8px; border:1px solid #eee; border-radius:10px;">
        <div class="row">
          <div>
            <b>Match ${mi+1}</b> ${badge}
            <div class="muted">Winner: ${winnerText} ‚Ä¢ ${when} ‚Ä¢ Games won: Alex ${gw[0]} - ${gw[1]} George</div>
          </div>
          <div style="margin-left:auto;">
            <button class="small danger" onclick="deleteMatch(${si}, ${mi})">Delete</button>
          </div>
        </div>
        <div>Scores (Alex‚ÄìGeorge): ${gamesStr || "<span class='muted'>No game scores</span>"}</div>
        ${report ? `<div class="muted">Report: ${escapeHtml(report)}</div>` : ""}
      </div>`;
    });
  });

  document.getElementById("history").innerHTML=html;
}

function renderCharts(){
  // destroy previous
  if(weekdayWinRateChartInstance) weekdayWinRateChartInstance.destroy();
  if(comebackMatchChartInstance) comebackMatchChartInstance.destroy();
  if(comebackSeasonChartInstance) comebackSeasonChartInstance.destroy();

  // Weekday win rate %
  const wr = computeWeekdayWinRatesPercent();
  weekdayWinRateChartInstance = new Chart(document.getElementById("weekdayWinRateChart"),{
    type:'bar',
    data:{
      labels: wr.labels,
      datasets:[
        { label:"Alex win %", data: wr.alexPct },
        { label:"George win %", data: wr.georgePct }
      ]
    },
    options: { scales: { y: { min: 0, max: 100 } } }
  });

  // Comeback match win %
  const cm = computeComebackMatchWinPercent();
  comebackMatchChartInstance = new Chart(document.getElementById("comebackMatchChart"),{
    type:'bar',
    data:{
      labels: ["Alex","George"],
      datasets:[{ label:"Comeback match wins (% of match wins)", data: cm.pct }]
    },
    options: { scales: { y: { min: 0, max: 100 } } }
  });

  // Comeback season win %
  const cs = computeComebackSeasonWinPercent();
  comebackSeasonChartInstance = new Chart(document.getElementById("comebackSeasonChart"),{
    type:'bar',
    data:{
      labels: ["Alex","George"],
      datasets:[{ label:"Comeback seasons (% of seasons won)", data: cs.pct }]
    },
    options: { scales: { y: { min: 0, max: 100 } } }
  });
}

/* ---------- INPUTS ---------- */
function createInputs(){
  let html="";
  html += `<div class="row muted" style="font-weight:600;">
    <div style="width:120px;"> </div>
    <div style="width:70px; text-align:center;">Alex</div>
    <div style="width:20px;"></div>
    <div style="width:70px; text-align:center;">George</div>
  </div>`;

  for(let i=0;i<5;i++){
    html += `<div class="row" style="align-items:center;">
      <div style="width:120px;">Game ${i+1}</div>
      <input id="a${i}" type="number" inputmode="numeric" />
      <div style="width:20px; text-align:center;">‚Äì</div>
      <input id="b${i}" type="number" inputmode="numeric" />
    </div>`;
  }

  html += `<div style="margin-top:8px;">
    Date: <input type="date" id="matchDate"> 
    Time: <input type="time" id="matchTime">
  </div>`;

  html += `Match Report (optional):<br><textarea id="matchReport"></textarea><br>`;

  document.getElementById("inputs").innerHTML=html;
  setDateTimeToNow();
}

/* ---------- ACTIONS ---------- */
window.addMatch = async function(){
  try {
    let games=[];
    for(let i=0;i<5;i++){
      const a = parseInt(document.getElementById("a"+i).value);
      const b = parseInt(document.getElementById("b"+i).value);
      if(!isNaN(a) && !isNaN(b)){
        games.push({ a: a, g: b });
      }
    }

    if(games.length === 0) return alert("Enter at least one game score.");

    const date = document.getElementById("matchDate").value;
    const time = document.getElementById("matchTime").value;
    const report = document.getElementById("matchReport").value;

    const outcome = computeMatchOutcome(games);

    const match = {
      games,
      date,
      time,
      report,
      completed: outcome.completed,
      winner: outcome.winner,
      gameWins: outcome.gameWins,
      comebackWin: outcome.comebackWin
    };

    const all = flattenMatchesInStoredOrder();
    all.push(match);
    rebuildSeasonsFromMatches(all);

    await saveData();
    resetMatchEntryForm();
    loadData();
  } catch (e){
    console.error(e);
    alert("Error adding match. Check Console.");
  }
};

window.deleteMatch = async function(seasonIndex, matchIndex){
  try {
    const ok = confirm(`Delete Season ${seasonIndex+1} - Match ${matchIndex+1}?\nThis can't be undone.`);
    if(!ok) return;

    const all = [];
    data.seasons.forEach((s, si)=>{
      (s.matches || []).forEach((m, mi)=>{
        if(!(si === seasonIndex && mi === matchIndex)) all.push(m);
      });
    });

    rebuildSeasonsFromMatches(all);
    await saveData();
    loadData();
  } catch (e){
    console.error(e);
    alert("Error deleting match. Check Console.");
  }
};

document.getElementById("addMatchBtn").addEventListener("click", () => {
  window.addMatch();
});

createInputs();
loadData();

</script>
</body>
</html>
