<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Alex vs George</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background:#f4f6f8; padding:20px; }
.card { background:white; padding:15px; margin-bottom:15px; border-radius:12px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }
input, textarea { width: 70px; margin:3px; }
textarea { width: 100%; height:50px; }
button { padding:8px 12px; border-radius:8px; border:none; background:black; color:white; margin-top:5px; cursor:pointer; }
button.danger { background:#b00020; }
button.small { padding:4px 8px; border-radius:6px; font-size:12px; margin-left:8px; }
table { width:100%; border-collapse:collapse; }
th,td { padding:6px; text-align:center; border-bottom:1px solid #eee; }
.muted { color:#666; font-size:12px; }
.row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
</style>
</head>
<body>

<h1>üèÜ Alex vs George</h1>

<div class="card">
  <h2>Leaderboard</h2>
  <table id="leaderboard"></table>
</div>

<div class="card">
  <h2>Current Season</h2>
  <div id="seasonScore"></div>
  <div class="muted" id="seasonMeta"></div>
</div>

<div class="card">
  <h2>Add Match</h2>
  <div id="inputs"></div>
  <button id="addMatchBtn">Add Match</button>
</div>

<div class="card">
  <h2>Match History</h2>
  <div class="muted">Tip: Deleting a match will automatically recalculate season scores and winners.</div>
  <div id="history"></div>
</div>

<div class="card">
  <h2>Charts</h2>
  <canvas id="seasonChart"></canvas>
  <br><br>
  <canvas id="matchChart"></canvas>
</div>

<script type="module">

const firebaseConfig = {
  apiKey: "AIzaSyDfpeuk-5wI3bAAOh799W20ZjCNKj6G4Nc",
  authDomain: "squash-rivalry.firebaseapp.com",
  projectId: "squash-rivalry",
  storageBucket: "squash-rivalry.firebasestorage.app",
  messagingSenderId: "9288441167",
  appId: "1:9288441167:web:2bf24a4bfdbe7af385b93a"
};

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

let data;
let seasonChartInstance = null;
let matchChartInstance = null;

function pad2(n){ return String(n).padStart(2, "0"); }

function setDateTimeToNow(){
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = pad2(d.getMonth()+1);
  const dd = pad2(d.getDate());
  const hh = pad2(d.getHours());
  const mi = pad2(d.getMinutes());
  const dateEl = document.getElementById("matchDate");
  const timeEl = document.getElementById("matchTime");
  if(dateEl) dateEl.value = `${yyyy}-${mm}-${dd}`;
  if(timeEl) timeEl.value = `${hh}:${mi}`;
}

function resetMatchEntryForm(){
  for(let i=0;i<5;i++){
    const a = document.getElementById("a"+i);
    const b = document.getElementById("b"+i);
    if(a) a.value = "";
    if(b) b.value = "";
  }
  const report = document.getElementById("matchReport");
  if(report) report.value = "";
  setDateTimeToNow();
}

async function loadData(){
  const snap = await getDoc(doc(db,"squash","main"));
  if(snap.exists()){
    data = snap.data();
  } else {
    data = {
      players:["Alex","George"],
      seasons:[{matches:[],wins:[0,0],winner:null}]
    };
    await saveData();
  }
  renderAll();
}

async function saveData(){
  await setDoc(doc(db,"squash","main"),data);
}

function flattenMatchesInStoredOrder(){
  const all = [];
  data.seasons.forEach(season => {
    (season.matches || []).forEach(match => all.push(match));
  });
  return all;
}

/**
 * Rebuild seasons from scratch based on match order currently stored.
 * This makes deletion safe even if you delete an old match that affects later seasons.
 */
function rebuildSeasonsFromMatches(allMatches){
  const seasons = [];
  let current = { matches: [], wins: [0,0], winner: null };

  for(const match of allMatches){
    current.matches.push(match);

    // winner is assumed to be 0 or 1 in current system
    if(match && (match.winner === 0 || match.winner === 1)){
      current.wins[match.winner]++;

      if(current.wins[match.winner] >= 5 && current.winner === null){
        current.winner = match.winner;
        seasons.push(current);
        current = { matches: [], wins: [0,0], winner: null };
      }
    }
  }

  // Always keep an open season at the end
  seasons.push(current);

  data.seasons = seasons;
}

function getCurrentSeason(){
  // We always keep an open season at end after rebuild
  return data.seasons[data.seasons.length-1];
}

function calculateStats(){
  let stats=[
    {name:"Alex",seasons:0,matches:0,gamesWon:0,gamesLost:0,pointsDiff:0},
    {name:"George",seasons:0,matches:0,gamesWon:0,gamesLost:0,pointsDiff:0}
  ];

  data.seasons.forEach(s=>{
    if(s.winner!==null) stats[s.winner].seasons++;

    (s.matches || []).forEach(m=>{
      if(m && (m.winner === 0 || m.winner === 1)) stats[m.winner].matches++;

      (m.games || []).forEach(g=>{
        const a = g.a;
        const b = g.g;

        // Guard against weird/partial values
        if(typeof a !== "number" || typeof b !== "number") return;

        stats[0].gamesWon += a>b ? 1 : 0;
        stats[1].gamesWon += b>a ? 1 : 0;
        stats[0].gamesLost += a<b ? 1 : 0;
        stats[1].gamesLost += b<a ? 1 : 0;

        stats[0].pointsDiff += a - b;
        stats[1].pointsDiff += b - a;
      });
    });
  });

  return stats.sort((a,b)=>b.seasons-a.seasons);
}

function renderAll(){
  renderLeaderboard();
  renderSeasonScore();
  renderHistory();
  renderCharts();
}

function renderLeaderboard(){
  let stats=calculateStats();
  let html="<tr><th>Player</th><th>Seasons</th><th>Matches</th><th>Games W</th><th>Games L</th><th>Points Diff</th></tr>";
  stats.forEach(p=>{
    html+=`<tr>
      <td>${p.name}</td>
      <td>${p.seasons}</td>
      <td>${p.matches}</td>
      <td>${p.gamesWon}</td>
      <td>${p.gamesLost}</td>
      <td>${p.pointsDiff}</td>
    </tr>`;
  });
  document.getElementById("leaderboard").innerHTML=html;
}

function renderSeasonScore(){
  let s=getCurrentSeason();
  document.getElementById("seasonScore").innerText =
    "Alex " + (s.wins?.[0] ?? 0) + " - " + (s.wins?.[1] ?? 0) + " George";

  document.getElementById("seasonMeta").innerText =
    "Season " + data.seasons.length + " (current)";
}

function renderHistory(){
  let html="";

  data.seasons.forEach((s, si)=>{
    html += `<div style="margin-top:10px;"><b>Season ${si+1}</b></div>`;

    if(!s.matches || s.matches.length === 0){
      html += `<div class="muted">No matches logged yet.</div>`;
      return;
    }

    s.matches.forEach((m, mi)=>{
      let date = m.date || "N/A";
      let time = m.time || "N/A";
      let report = m.report || "";
      let gamesStr = (m.games || []).map(g => `${g.a}-${g.g}`).join(", ");

      html += `<div style="margin-top:8px; padding:8px; border:1px solid #eee; border-radius:10px;">
        <div class="row">
          <div>
            <b>Match ${mi+1}</b>
            <span class="muted">‚Ä¢ Winner: ${data.players[m.winner] ?? "N/A"} ‚Ä¢ ${date} ${time}</span>
          </div>
          <div style="margin-left:auto;">
            <button class="small danger" onclick="deleteMatch(${si}, ${mi})">Delete</button>
          </div>
        </div>
        <div>Games: ${gamesStr || "<span class='muted'>No game scores</span>"}</div>
        ${report ? `<div class="muted">Report: ${escapeHtml(report)}</div>` : ""}
      </div>`;
    });
  });

  document.getElementById("history").innerHTML=html;
}

function escapeHtml(str){
  return String(str)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function renderCharts(){
  let stats=calculateStats();

  // prevent charts stacking on rerender
  if(seasonChartInstance) seasonChartInstance.destroy();
  if(matchChartInstance) matchChartInstance.destroy();

  seasonChartInstance = new Chart(document.getElementById("seasonChart"),{
    type:'bar',
    data:{
      labels:stats.map(p=>p.name),
      datasets:[{label:"Seasons Won",data:stats.map(p=>p.seasons)}]
    }
  });

  matchChartInstance = new Chart(document.getElementById("matchChart"),{
    type:'bar',
    data:{
      labels:stats.map(p=>p.name),
      datasets:[{label:"Matches Won",data:stats.map(p=>p.matches)}]
    }
  });
}

function createInputs(){
  let html="";
  for(let i=0;i<5;i++){
    html+=`Game ${i+1}: <input id="a${i}" type="number"> - <input id="b${i}" type="number"><br>`;
  }
  html+=`Date: <input type="date" id="matchDate"> Time: <input type="time" id="matchTime"><br>`;
  html+=`Match Report (optional):<br><textarea id="matchReport"></textarea><br>`;
  document.getElementById("inputs").innerHTML=html;

  // default to now on load
  setDateTimeToNow();
}

window.addMatch = async function(){
  let games=[];
  let wins=[0,0];

  for(let i=0;i<5;i++){
    let a=parseInt(document.getElementById("a"+i).value);
    let b=parseInt(document.getElementById("b"+i).value);

    if(!isNaN(a) && !isNaN(b)){
      games.push({ a: a, g: b });
      if(a>b) wins[0]++;
      if(b>a) wins[1]++;
    }
  }

  if(wins[0]===0 && wins[1]===0) return alert("Enter at least one game score.");

  let winner = wins[0] > wins[1] ? 0 : 1;
  let date = document.getElementById("matchDate").value;
  let time = document.getElementById("matchTime").value;
  let report = document.getElementById("matchReport").value;

  const match = { games, winner, date, time, report };

  // Add match to current season, then rebuild seasons to keep everything consistent
  const all = flattenMatchesInStoredOrder();
  all.push(match);
  rebuildSeasonsFromMatches(all);

  await saveData();

  // UX: reset entry immediately
  resetMatchEntryForm();

  // refresh UI from DB
  loadData();
};

window.deleteMatch = async function(seasonIndex, matchIndex){
  const ok = confirm(`Delete Season ${seasonIndex+1} - Match ${matchIndex+1}?\nThis can't be undone.`);
  if(!ok) return;

  // Flatten, remove the selected match (by position in stored order), rebuild seasons
  const all = [];
  data.seasons.forEach((s, si)=>{
    (s.matches || []).forEach((m, mi)=>{
      if(!(si === seasonIndex && mi === matchIndex)) all.push(m);
    });
  });

  rebuildSeasonsFromMatches(all);
  await saveData();
  loadData();
};

document.getElementById("addMatchBtn").addEventListener("click", () => {
  window.addMatch();
});

createInputs();
loadData();

</script>
</body>
</html>
